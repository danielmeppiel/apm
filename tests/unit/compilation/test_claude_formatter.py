"""Unit tests for ClaudeFormatter - CLAUDE.md generation and commands."""

import tempfile
import shutil
from pathlib import Path

import pytest

from apm_cli.compilation.claude_formatter import (
    ClaudeFormatter,
    ClaudePlacement,
    ClaudeCompilationResult,
    CommandGenerationResult,
    format_claude_md,
    generate_claude_commands,
    CLAUDE_HEADER,
)
from apm_cli.compilation.constants import BUILD_ID_PLACEHOLDER
from apm_cli.primitives.models import Instruction, Chatmode, PrimitiveCollection
from apm_cli.version import get_version


class TestClaudeFormatterInit:
    """Tests for ClaudeFormatter initialization."""

    def test_init_with_valid_directory(self, tmp_path):
        """Test initialization with a valid directory path."""
        formatter = ClaudeFormatter(str(tmp_path))
        assert formatter.base_dir == tmp_path
        assert formatter.warnings == []
        assert formatter.errors == []

    def test_init_with_current_directory(self):
        """Test initialization with default current directory."""
        formatter = ClaudeFormatter()
        assert formatter.base_dir.exists()

    def test_init_with_relative_path(self, tmp_path):
        """Test initialization with relative path."""
        formatter = ClaudeFormatter(".")
        assert formatter.base_dir.is_absolute()


class TestFormatDistributed:
    """Tests for format_distributed() method."""

    @pytest.fixture
    def temp_project(self):
        """Create a temporary project directory."""
        temp_dir = tempfile.mkdtemp()
        yield Path(temp_dir)
        shutil.rmtree(temp_dir, ignore_errors=True)

    @pytest.fixture
    def sample_primitives(self, temp_project):
        """Create sample primitives for testing."""
        primitives = PrimitiveCollection()
        
        # Add instructions
        instruction1 = Instruction(
            name="python-style",
            file_path=temp_project / ".github/instructions/python.instructions.md",
            description="Python coding standards",
            apply_to="**/*.py",
            content="Use type hints and follow PEP 8.",
            author="test",
            source="local"
        )
        
        instruction2 = Instruction(
            name="js-style",
            file_path=temp_project / ".github/instructions/js.instructions.md",
            description="JavaScript coding standards",
            apply_to="**/*.js",
            content="Use ES6+ features.",
            author="test",
            source="local"
        )
        
        primitives.add_primitive(instruction1)
        primitives.add_primitive(instruction2)
        
        return primitives

    def test_format_generates_header(self, temp_project, sample_primitives):
        """Test that CLAUDE.md contains correct header format."""
        formatter = ClaudeFormatter(str(temp_project))
        
        placement_map = {temp_project: list(sample_primitives.instructions)}
        result = formatter.format_distributed(sample_primitives, placement_map)
        
        assert result.success
        assert len(result.content_map) == 1
        
        content = result.content_map[temp_project / "CLAUDE.md"]
        assert "# CLAUDE.md" in content
        assert CLAUDE_HEADER in content
        assert BUILD_ID_PLACEHOLDER in content
        assert f"<!-- APM Version: {get_version()} -->" in content

    def test_format_generates_footer(self, temp_project, sample_primitives):
        """Test that CLAUDE.md contains correct footer."""
        formatter = ClaudeFormatter(str(temp_project))
        
        placement_map = {temp_project: list(sample_primitives.instructions)}
        result = formatter.format_distributed(sample_primitives, placement_map)
        
        content = result.content_map[temp_project / "CLAUDE.md"]
        assert "*This file was generated by APM CLI. Do not edit manually.*" in content
        assert "*To regenerate: `apm compile`*" in content

    def test_format_groups_by_apply_to_patterns(self, temp_project, sample_primitives):
        """Test that instructions are grouped by applyTo patterns."""
        formatter = ClaudeFormatter(str(temp_project))
        
        placement_map = {temp_project: list(sample_primitives.instructions)}
        result = formatter.format_distributed(sample_primitives, placement_map)
        
        content = result.content_map[temp_project / "CLAUDE.md"]
        
        # Check pattern grouping
        assert "## Files matching `**/*.py`" in content
        assert "## Files matching `**/*.js`" in content
        assert "Use type hints and follow PEP 8." in content
        assert "Use ES6+ features." in content

    def test_format_includes_project_standards_section(self, temp_project, sample_primitives):
        """Test that Project Standards section is generated."""
        formatter = ClaudeFormatter(str(temp_project))
        
        placement_map = {temp_project: list(sample_primitives.instructions)}
        result = formatter.format_distributed(sample_primitives, placement_map)
        
        content = result.content_map[temp_project / "CLAUDE.md"]
        assert "# Project Standards" in content

    def test_format_includes_source_attribution(self, temp_project, sample_primitives):
        """Test that source attribution comments are included."""
        formatter = ClaudeFormatter(str(temp_project))
        
        placement_map = {temp_project: list(sample_primitives.instructions)}
        config = {'source_attribution': True}
        result = formatter.format_distributed(sample_primitives, placement_map, config)
        
        content = result.content_map[temp_project / "CLAUDE.md"]
        assert "<!-- Source:" in content

    def test_format_without_source_attribution(self, temp_project, sample_primitives):
        """Test that source attribution can be disabled."""
        formatter = ClaudeFormatter(str(temp_project))
        
        placement_map = {temp_project: list(sample_primitives.instructions)}
        config = {'source_attribution': False}
        result = formatter.format_distributed(sample_primitives, placement_map, config)
        
        # Source attribution should not be tracked in placement
        for placement in result.placements:
            assert placement.source_attribution == {}

    def test_format_returns_compilation_stats(self, temp_project, sample_primitives):
        """Test that compilation statistics are returned."""
        formatter = ClaudeFormatter(str(temp_project))
        
        placement_map = {temp_project: list(sample_primitives.instructions)}
        result = formatter.format_distributed(sample_primitives, placement_map)
        
        assert result.stats['claude_files_generated'] == 1
        assert result.stats['total_instructions_placed'] == 2
        assert result.stats['total_patterns_covered'] == 2

    def test_format_empty_placement_map(self, temp_project):
        """Test formatting with empty placement map."""
        formatter = ClaudeFormatter(str(temp_project))
        primitives = PrimitiveCollection()
        
        result = formatter.format_distributed(primitives, {})
        
        assert result.success
        # No files should be generated without instructions or constitution
        assert len(result.content_map) == 0

    def test_format_with_constitution(self, temp_project):
        """Test formatting with constitution file."""
        # Create constitution file
        constitution_file = temp_project / "CONSTITUTION.md"
        constitution_file.write_text("# Constitution\n\nBe helpful and accurate.")
        
        formatter = ClaudeFormatter(str(temp_project))
        primitives = PrimitiveCollection()
        
        # Empty placement map but constitution exists
        result = formatter.format_distributed(primitives, {})
        
        assert result.success
        if result.content_map:
            content = list(result.content_map.values())[0]
            assert "# Constitution" in content
            assert "Be helpful and accurate." in content


class TestDependenciesImportSyntax:
    """Tests for @import syntax for dependencies."""

    @pytest.fixture
    def temp_project_with_deps(self):
        """Create a temporary project with apm_modules dependencies."""
        temp_dir = tempfile.mkdtemp()
        temp_path = Path(temp_dir).resolve()
        
        # Create apm_modules structure
        apm_modules = temp_path / "apm_modules"
        (apm_modules / "owner1" / "package1").mkdir(parents=True)
        (apm_modules / "owner2" / "package2").mkdir(parents=True)
        
        yield temp_path
        shutil.rmtree(temp_dir, ignore_errors=True)

    def test_dependencies_use_import_syntax(self, temp_project_with_deps):
        """Test that dependencies are listed with @import syntax."""
        formatter = ClaudeFormatter(str(temp_project_with_deps))
        primitives = PrimitiveCollection()
        
        instruction = Instruction(
            name="test",
            file_path=temp_project_with_deps / "test.instructions.md",
            description="Test",
            apply_to="**/*.py",
            content="Test content",
            author="test"
        )
        primitives.add_primitive(instruction)
        
        # Use resolved path for placement map key
        placement_map = {formatter.base_dir: [instruction]}
        result = formatter.format_distributed(primitives, placement_map)
        
        # Get content using the resolved path
        content = result.content_map[formatter.base_dir / "CLAUDE.md"]
        
        # Check @import syntax
        assert "@apm_modules/owner1/package1/CLAUDE.md" in content
        assert "@apm_modules/owner2/package2/CLAUDE.md" in content
        assert "# Dependencies" in content

    def test_dependencies_are_sorted(self, temp_project_with_deps):
        """Test that dependencies are sorted alphabetically."""
        formatter = ClaudeFormatter(str(temp_project_with_deps))
        deps = formatter._collect_dependencies()
        
        assert deps == sorted(deps)

    def test_no_dependencies_section_when_no_apm_modules(self, tmp_path):
        """Test that no Dependencies section when apm_modules doesn't exist."""
        formatter = ClaudeFormatter(str(tmp_path))
        deps = formatter._collect_dependencies()
        
        assert deps == []


class TestAgentsAndWorkflows:
    """Tests for agents/workflows inclusion in CLAUDE.md."""

    @pytest.fixture
    def temp_project(self):
        """Create a temporary project directory."""
        temp_dir = tempfile.mkdtemp()
        yield Path(temp_dir).resolve()
        shutil.rmtree(temp_dir, ignore_errors=True)

    def test_agents_included_in_workflows_section(self, temp_project):
        """Test that agents/chatmodes are included in Workflows section."""
        formatter = ClaudeFormatter(str(temp_project))
        primitives = PrimitiveCollection()
        
        chatmode = Chatmode(
            name="code-reviewer",
            file_path=temp_project / ".github/chatmodes/code-reviewer.chatmode.md",
            description="Expert code reviewer",
            apply_to=None,
            content="You are an expert code reviewer. Focus on security and performance.",
            author="test"
        )
        primitives.add_primitive(chatmode)
        
        instruction = Instruction(
            name="test",
            file_path=temp_project / "test.instructions.md",
            description="Test",
            apply_to="**/*.py",
            content="Test content",
            author="test"
        )
        primitives.add_primitive(instruction)
        
        # Use the formatter's resolved base_dir as the key
        placement_map = {formatter.base_dir: [instruction]}
        result = formatter.format_distributed(primitives, placement_map)
        
        content = result.content_map[formatter.base_dir / "CLAUDE.md"]
        
        assert "# Workflows" in content
        assert "## code-reviewer" in content
        assert "*Expert code reviewer*" in content
        assert "You are an expert code reviewer." in content

    def test_agents_only_in_root_claude_md(self, temp_project):
        """Test that agents are only included in root CLAUDE.md."""
        formatter = ClaudeFormatter(str(temp_project))
        primitives = PrimitiveCollection()
        
        chatmode = Chatmode(
            name="reviewer",
            file_path=temp_project / "reviewer.chatmode.md",
            description="Reviewer",
            apply_to=None,
            content="You are a reviewer.",
            author="test"
        )
        primitives.add_primitive(chatmode)
        
        instruction = Instruction(
            name="test",
            file_path=temp_project / "test.instructions.md",
            description="Test",
            apply_to="src/**/*.py",
            content="Test content",
            author="test"
        )
        primitives.add_primitive(instruction)
        
        # Create subdirectory placement using resolved paths
        src_dir = formatter.base_dir / "src"
        src_dir.mkdir(exist_ok=True)
        
        placement_map = {
            formatter.base_dir: [instruction],
            src_dir: [instruction]
        }
        result = formatter.format_distributed(primitives, placement_map)
        
        # Root should have workflows
        root_content = result.content_map[formatter.base_dir / "CLAUDE.md"]
        assert "# Workflows" in root_content
        
        # Subdirectory should not have workflows
        src_content = result.content_map[src_dir / "CLAUDE.md"]
        assert "# Workflows" not in src_content

    def test_multiple_agents_included(self, temp_project):
        """Test that multiple agents are all included."""
        formatter = ClaudeFormatter(str(temp_project))
        primitives = PrimitiveCollection()
        
        chatmode1 = Chatmode(
            name="reviewer",
            file_path=temp_project / "reviewer.chatmode.md",
            description="Code reviewer",
            apply_to=None,
            content="Review code.",
            author="test"
        )
        chatmode2 = Chatmode(
            name="architect",
            file_path=temp_project / "architect.chatmode.md",
            description="System architect",
            apply_to=None,
            content="Design systems.",
            author="test"
        )
        primitives.add_primitive(chatmode1)
        primitives.add_primitive(chatmode2)
        
        instruction = Instruction(
            name="test",
            file_path=temp_project / "test.instructions.md",
            description="Test",
            apply_to="**/*.py",
            content="Test",
            author="test"
        )
        primitives.add_primitive(instruction)
        
        placement_map = {formatter.base_dir: [instruction]}
        result = formatter.format_distributed(primitives, placement_map)
        
        content = result.content_map[formatter.base_dir / "CLAUDE.md"]
        
        assert "## reviewer" in content
        assert "## architect" in content
        assert "Review code." in content
        assert "Design systems." in content


class TestGenerateCommands:
    """Tests for generate_commands() method - .claude/commands/ generation."""

    @pytest.fixture
    def temp_project(self):
        """Create a temporary project directory."""
        temp_dir = tempfile.mkdtemp()
        yield Path(temp_dir).resolve()
        shutil.rmtree(temp_dir, ignore_errors=True)

    def test_generate_commands_creates_directory(self, temp_project):
        """Test that .claude/commands/ directory is created."""
        formatter = ClaudeFormatter(str(temp_project))
        
        # Create a prompt file
        prompts_dir = temp_project / ".github" / "prompts"
        prompts_dir.mkdir(parents=True)
        prompt_file = prompts_dir / "code-review.prompt.md"
        prompt_file.write_text("""---
description: Review code for issues
---
Review the following code for bugs and security issues.
""")
        
        result = formatter.generate_commands([prompt_file], dry_run=False)
        
        assert result.success
        assert result.files_written == 1
        assert result.commands_dir.exists()
        assert (result.commands_dir / "code-review.md").exists()

    def test_generate_commands_dry_run(self, temp_project):
        """Test that dry_run mode doesn't write files."""
        formatter = ClaudeFormatter(str(temp_project))
        
        prompts_dir = temp_project / ".github" / "prompts"
        prompts_dir.mkdir(parents=True)
        prompt_file = prompts_dir / "test.prompt.md"
        prompt_file.write_text("""---
description: Test prompt
---
Test content.
""")
        
        result = formatter.generate_commands([prompt_file], dry_run=True)
        
        assert result.success
        assert result.files_written == 0
        assert len(result.commands_generated) == 1
        assert not result.commands_dir.exists()

    def test_generate_commands_preserves_frontmatter(self, temp_project):
        """Test that command files preserve frontmatter."""
        formatter = ClaudeFormatter(str(temp_project))
        
        prompts_dir = temp_project / ".github" / "prompts"
        prompts_dir.mkdir(parents=True)
        prompt_file = prompts_dir / "review.prompt.md"
        prompt_file.write_text("""---
description: Review code thoroughly
model: claude-3-opus
allowed-tools: Read, Write
argument-hint: <file-path>
---
Review this code: $ARGUMENTS
""")
        
        result = formatter.generate_commands([prompt_file], dry_run=True)
        
        # Get content by finding the command in the generated dict
        content = list(result.commands_generated.values())[0]
        
        assert "---" in content
        assert "description: Review code thoroughly" in content
        assert "model: claude-3-opus" in content
        assert "allowed-tools: Read, Write" in content
        assert "argument-hint: <file-path>" in content

    def test_generate_commands_adds_arguments_placeholder(self, temp_project):
        """Test that $ARGUMENTS placeholder is added when missing."""
        formatter = ClaudeFormatter(str(temp_project))
        
        prompts_dir = temp_project / ".github" / "prompts"
        prompts_dir.mkdir(parents=True)
        prompt_file = prompts_dir / "simple.prompt.md"
        prompt_file.write_text("""---
description: Simple prompt
---
Do something simple.
""")
        
        result = formatter.generate_commands([prompt_file], dry_run=True)
        
        content = list(result.commands_generated.values())[0]
        
        assert "$ARGUMENTS" in content
        assert any("Added $ARGUMENTS placeholder" in w for w in result.warnings)

    def test_generate_commands_preserves_existing_arguments(self, temp_project):
        """Test that existing $ARGUMENTS is not duplicated."""
        formatter = ClaudeFormatter(str(temp_project))
        
        prompts_dir = temp_project / ".github" / "prompts"
        prompts_dir.mkdir(parents=True)
        prompt_file = prompts_dir / "with-args.prompt.md"
        prompt_file.write_text("""---
description: Prompt with arguments
---
Process this input: $ARGUMENTS
""")
        
        result = formatter.generate_commands([prompt_file], dry_run=True)
        
        content = list(result.commands_generated.values())[0]
        
        # Should have exactly one $ARGUMENTS
        assert content.count("$ARGUMENTS") == 1
        # No warning about adding placeholder
        assert not any("Added $ARGUMENTS" in w for w in result.warnings)

    def test_generate_commands_preserves_positional_args(self, temp_project):
        """Test that positional args ($1, $2, etc.) are preserved without adding $ARGUMENTS."""
        formatter = ClaudeFormatter(str(temp_project))
        
        prompts_dir = temp_project / ".github" / "prompts"
        prompts_dir.mkdir(parents=True)
        prompt_file = prompts_dir / "positional.prompt.md"
        prompt_file.write_text("""---
description: Prompt with positional args
---
Compare $1 with $2.
""")
        
        result = formatter.generate_commands([prompt_file], dry_run=True)
        
        content = list(result.commands_generated.values())[0]
        
        assert "$1" in content
        assert "$2" in content
        # Should not add $ARGUMENTS when positional args exist
        assert not any("Added $ARGUMENTS" in w for w in result.warnings)

    def test_generate_commands_extracts_name_from_filename(self, temp_project):
        """Test that command name is extracted from filename correctly."""
        formatter = ClaudeFormatter(str(temp_project))
        
        prompts_dir = temp_project / ".github" / "prompts"
        prompts_dir.mkdir(parents=True)
        
        prompt_file = prompts_dir / "my-custom-command.prompt.md"
        prompt_file.write_text("""---
description: Custom command
---
Content.
""")
        
        result = formatter.generate_commands([prompt_file], dry_run=True)
        
        # Check that the command name is correct by looking at the keys
        command_names = [p.name for p in result.commands_generated.keys()]
        assert "my-custom-command.md" in command_names

    def test_generate_commands_maps_camelcase_frontmatter(self, temp_project):
        """Test that camelCase frontmatter is mapped correctly."""
        formatter = ClaudeFormatter(str(temp_project))
        
        prompts_dir = temp_project / ".github" / "prompts"
        prompts_dir.mkdir(parents=True)
        prompt_file = prompts_dir / "camel.prompt.md"
        prompt_file.write_text("""---
description: Test camelCase
allowedTools: Read, Write, Bash
argumentHint: <path>
---
Content here.
""")
        
        result = formatter.generate_commands([prompt_file], dry_run=True)
        
        content = list(result.commands_generated.values())[0]
        
        # Should convert to kebab-case
        assert "allowed-tools: Read, Write, Bash" in content
        assert "argument-hint: <path>" in content


class TestDiscoverPromptFiles:
    """Tests for discover_prompt_files() method."""

    @pytest.fixture
    def temp_project(self):
        """Create a temporary project directory."""
        temp_dir = tempfile.mkdtemp()
        yield Path(temp_dir)
        shutil.rmtree(temp_dir, ignore_errors=True)

    def test_discovers_prompts_in_github_prompts(self, temp_project):
        """Test discovery in .github/prompts/."""
        prompts_dir = temp_project / ".github" / "prompts"
        prompts_dir.mkdir(parents=True)
        (prompts_dir / "test.prompt.md").write_text("Test content")
        
        formatter = ClaudeFormatter(str(temp_project))
        files = formatter.discover_prompt_files()
        
        assert len(files) == 1
        assert "test.prompt.md" in str(files[0])

    def test_discovers_prompts_in_apm_prompts(self, temp_project):
        """Test discovery in .apm/prompts/."""
        prompts_dir = temp_project / ".apm" / "prompts"
        prompts_dir.mkdir(parents=True)
        (prompts_dir / "apm-test.prompt.md").write_text("APM test")
        
        formatter = ClaudeFormatter(str(temp_project))
        files = formatter.discover_prompt_files()
        
        assert len(files) == 1
        assert "apm-test.prompt.md" in str(files[0])

    def test_discovers_prompts_in_root(self, temp_project):
        """Test discovery of prompts in root directory."""
        (temp_project / "root-prompt.prompt.md").write_text("Root prompt")
        
        formatter = ClaudeFormatter(str(temp_project))
        files = formatter.discover_prompt_files()
        
        assert len(files) == 1
        assert "root-prompt.prompt.md" in str(files[0])

    def test_discovers_prompts_in_apm_modules(self, temp_project):
        """Test discovery in apm_modules dependencies."""
        prompts_dir = temp_project / "apm_modules" / "owner" / "package" / "prompts"
        prompts_dir.mkdir(parents=True)
        (prompts_dir / "dep-prompt.prompt.md").write_text("Dependency prompt")
        
        formatter = ClaudeFormatter(str(temp_project))
        files = formatter.discover_prompt_files()
        
        assert len(files) == 1
        assert "dep-prompt.prompt.md" in str(files[0])

    def test_no_duplicates_in_discovery(self, temp_project):
        """Test that duplicate files are not returned."""
        prompts_dir = temp_project / ".github" / "prompts"
        prompts_dir.mkdir(parents=True)
        (prompts_dir / "unique.prompt.md").write_text("Unique")
        
        formatter = ClaudeFormatter(str(temp_project))
        files = formatter.discover_prompt_files()
        
        # Even if we call it twice, should have unique files
        files2 = formatter.discover_prompt_files()
        assert len(files) == len(files2) == 1


class TestConvenienceFunctions:
    """Tests for module-level convenience functions."""

    @pytest.fixture
    def temp_project(self):
        """Create a temporary project directory."""
        temp_dir = tempfile.mkdtemp()
        yield Path(temp_dir)
        shutil.rmtree(temp_dir, ignore_errors=True)

    def test_format_claude_md_function(self, temp_project):
        """Test the format_claude_md convenience function."""
        primitives = PrimitiveCollection()
        
        instruction = Instruction(
            name="test",
            file_path=temp_project / "test.instructions.md",
            description="Test",
            apply_to="**/*.py",
            content="Test content",
            author="test"
        )
        primitives.add_primitive(instruction)
        
        placement_map = {temp_project: [instruction]}
        
        result = format_claude_md(primitives, placement_map, str(temp_project))
        
        assert result.success
        assert len(result.content_map) == 1

    def test_generate_claude_commands_function(self, temp_project):
        """Test the generate_claude_commands convenience function."""
        prompts_dir = temp_project / ".github" / "prompts"
        prompts_dir.mkdir(parents=True)
        (prompts_dir / "test.prompt.md").write_text("""---
description: Test
---
Test content.
""")
        
        result = generate_claude_commands(str(temp_project), dry_run=True)
        
        assert result.success
        assert len(result.commands_generated) == 1

    def test_generate_claude_commands_with_explicit_files(self, temp_project):
        """Test generate_claude_commands with explicit file list."""
        prompts_dir = temp_project / ".github" / "prompts"
        prompts_dir.mkdir(parents=True)
        prompt_file = prompts_dir / "explicit.prompt.md"
        prompt_file.write_text("""---
description: Explicit
---
Explicit content.
""")
        
        result = generate_claude_commands(
            str(temp_project),
            prompt_files=[prompt_file],
            dry_run=True
        )
        
        assert result.success
        assert len(result.commands_generated) == 1


class TestDataclasses:
    """Tests for dataclass structures."""

    def test_claude_placement_defaults(self):
        """Test ClaudePlacement default values."""
        placement = ClaudePlacement(
            claude_path=Path("test/CLAUDE.md"),
            instructions=[]
        )
        
        assert placement.agents == []
        assert placement.dependencies == []
        assert placement.coverage_patterns == set()
        assert placement.source_attribution == {}

    def test_claude_compilation_result_defaults(self):
        """Test ClaudeCompilationResult default values."""
        result = ClaudeCompilationResult(
            success=True,
            placements=[],
            content_map={}
        )
        
        assert result.warnings == []
        assert result.errors == []
        assert result.stats == {}

    def test_command_generation_result_defaults(self):
        """Test CommandGenerationResult default values."""
        result = CommandGenerationResult(
            success=True,
            commands_generated={},
            commands_dir=Path(".claude/commands"),
            files_written=0
        )
        
        assert result.warnings == []
        assert result.errors == []


class TestErrorHandling:
    """Tests for error handling in ClaudeFormatter."""

    @pytest.fixture
    def temp_project(self):
        """Create a temporary project directory."""
        temp_dir = tempfile.mkdtemp()
        yield Path(temp_dir)
        shutil.rmtree(temp_dir, ignore_errors=True)

    def test_format_distributed_handles_exceptions(self, temp_project):
        """Test that format_distributed handles exceptions gracefully."""
        formatter = ClaudeFormatter(str(temp_project))
        
        # Pass invalid data that might cause an error
        primitives = PrimitiveCollection()
        
        # Create instruction with None for required field to potentially cause error
        instruction = Instruction(
            name="test",
            file_path=temp_project / "test.md",
            description="Test",
            apply_to="**/*.py",
            content="Test",
            author="test"
        )
        primitives.add_primitive(instruction)
        
        result = formatter.format_distributed(primitives, {temp_project: [instruction]})
        
        # Should succeed or fail gracefully
        assert isinstance(result, ClaudeCompilationResult)

    def test_generate_commands_handles_invalid_file(self, temp_project):
        """Test that generate_commands handles invalid prompt files."""
        formatter = ClaudeFormatter(str(temp_project))
        
        # Try to process a non-existent file
        nonexistent = temp_project / "nonexistent.prompt.md"
        
        result = formatter.generate_commands([nonexistent], dry_run=True)
        
        # Should report error but not crash
        assert len(result.errors) > 0

    def test_generate_commands_handles_malformed_frontmatter(self, temp_project):
        """Test handling of malformed frontmatter in prompt files."""
        formatter = ClaudeFormatter(str(temp_project))
        
        prompts_dir = temp_project / ".github" / "prompts"
        prompts_dir.mkdir(parents=True)
        
        # Create file with invalid YAML frontmatter
        prompt_file = prompts_dir / "malformed.prompt.md"
        prompt_file.write_text("""---
description: [unclosed bracket
---
Content here.
""")
        
        result = formatter.generate_commands([prompt_file], dry_run=True)
        
        # Should handle gracefully (either error or skip)
        assert isinstance(result, CommandGenerationResult)
